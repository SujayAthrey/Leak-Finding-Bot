import java.util.*;

public class Bots {
    ShipGenerator shipGenerator; //shipGenerator object is an instance of our ShipGenerator class
    private int[][] ship; //our generated ship we will run the simulations on
    private int[] botPosition, leakPosition, secondLeakPosition; //initial position of the bot, leak, and second leak position (needed for some bots)
    private int rows, cols; //stores the dimensions of our generated ship
    private int k; //k will be a passed in value to determine the size of detection square... A = (2k+1)^2
    private int maxIterations = 20000; //maxIterations is a constant used to prevent some methods for looping continously and running out of heap space and memory
    private double[][] leakProbabilities;// boolean arrays of same size as 'ship' to store the different probabilities of giving a beep if the leak is nearby
    private int totalMoves = 0, totalScans = 0; //stores the total number of moves and total number of scans/senses that a bot takes 
    private double alpha; //alpha value used in the probability calculation that is passed in

    //Bots constructor takes in the ship generated by ShipGenerator and our k value for the detection square size
    public Bots(ShipGenerator shipGenerator, int k) {
        //retrieves all necessary info, including an instance of the ShipGenerator class, the ship, the dimensions, initial positions, and our k value
        this.shipGenerator = shipGenerator;
        this.ship = shipGenerator.getShip();
        this.rows = shipGenerator.getRows();
        this.cols = shipGenerator.getCols();
        this.botPosition = shipGenerator.getKeyPosition(ship, 2);
        this.leakPosition = shipGenerator.getKeyPosition(ship, 3);
        this.k = k;
    }
    //Overloaded Bots constructor takes in the ship generated by ShipGenerator, our k value, and our alpha value used in bots that use probabilistic leak detection
    public Bots(ShipGenerator shipGenerator, int k, double alpha) {
        //retrieves the same info as previous constructor, with the addition of an alpha value, and the different boolean arrays that store the calculated probabilities
        this.shipGenerator = shipGenerator;
        this.ship = shipGenerator.getShip();
        this.rows = shipGenerator.getRows();
        this.cols = shipGenerator.getCols();
        this.botPosition = shipGenerator.getKeyPosition(ship, 2);
        this.leakPosition = shipGenerator.getKeyPosition(ship, 3);
        this.k = k;
        this.alpha = alpha;
        this.leakProbabilities = initializeLeakProbabilities();
    }

    private boolean[][] initializePossibleLeakPositions() { //this method will simply create a new boolean array of the same size of the ship and initialize all its values to "true"
        boolean[][] possibleLeakPositions = new boolean[rows][cols];

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                possibleLeakPositions[i][j] = true; //we set each position to "true" because initially, any cell in the ship could contain the leak
            }
        }
        return possibleLeakPositions; //return the initialized array with every value set to "true" at first
    }
    
    private double[][] initializeLeakProbabilities() { //initialize a new double array of the same size of the ship with an equal probability of containing the leak for all cell values
        double[][] probabilities = new double[rows][cols];

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                probabilities[i][j] = 1.0 / (rows * cols); //the probability of each cell will equal 1 divided by the dimensions of the ship, this will in hand equally split every cell to an equal probability, where it ranges from 0 to 1
            }
        }
        return probabilities;
    }

    private boolean inShip(int row, int col) { //this method checks to make sure the position is within the ship boundaries
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }

    private double euclideanDistance(int rowOne, int colOne, int rowTwo, int colTwo) { //this method will calculate the Euclidean distance between two points (row1, col1) and (row2, col2)
        return Math.sqrt(Math.pow(rowOne - rowTwo, 2) + Math.pow(colOne - colTwo, 2)); //apply distance formula
    }
    
    private boolean withinDetectionSquare(int row, int col, int botRow, int botCol, int k) {  //checks wether or not a (row,col) coordinate is in the 'detection square' of position (botRow, botCol)
        //store the row and column boundaries of the square in 4 seperate x/y values
        int y1Square = Math.max(0, botRow - k);
        int y2Square = Math.min(rows - 1, botRow + k);
        int x1Square = Math.max(0, botCol - k);
        int x2Square = Math.min(cols - 1, botCol + k);

        return row >= y1Square && row <= y2Square && col >= x1Square && col <= x2Square; //returns true if position is within the detection square and false otherwise
    }

    private void displayTotalActions(){ //this method will display the total number of actions a bot takes during its sensing/simulation path. The total num of actions is the amount of times it moved plus the amount of time it senses
        System.out.println("Total scans taken by bot:" + totalScans + "Total moves taken by bot:" + totalMoves);
    }

    private void addSecondLeakPos() { //this method will generate a position for a second leak in our ship, making sure that this second leak is also outside the detection square of the initial bot position
        Random random = new Random(); //create 'random' object 

        do {
            //generate new random coordinate
            int randRow = random.nextInt(rows); 
            int randCol = random.nextInt(cols);
            //set our second leak position equal to that coordinate
            secondLeakPosition = new int[]{randRow, randCol};
            
        } while (withinDetectionSquare(secondLeakPosition[0], secondLeakPosition[1], botPosition[0], botPosition[1], k)); //makes sure that the second leak is generated and does not overlap the previous leak pos, bot pos, and that it is outside the detection square of the initial bot position

    }

    private int[] BFSTrueCell(int row, int col, boolean[][] possibleLeakPositions) { //this method uses BFS path planning algorithm for the bot to travel from its current location to the nearest cell location that could possibly contain the leak
                                                                                     //the nearest cell loc. that could possibly contain the leak = closest cell coordinate in possibleLeakPositions boolean array with value of "True" from the bot
        Queue<int[]> botQueue = new LinkedList<>(); //create a botQueue for our BFS
        boolean[][] visited = new boolean[rows][cols]; //create a visited boolean array for our BFS

        botQueue.add(botPosition); //add the bot position to the BFS queue to begin, and set it equal to true in the visited array
        visited[botPosition[0]][botPosition[1]] = true;

        //follow standard BFS algorithm, including a loop that runs until the queue is empty
        //poll the current cell, visit all neighbors of current cell in breadth-wise fashion, set each neighbor to visited... etc
        while (!botQueue.isEmpty()) { 
            //retrieves coordinates of current cell in queue
            int[] currentCell = botQueue.poll();
            int currentRow = currentCell[0]; 
            int currentCol = currentCell[1];

            if (possibleLeakPositions[currentRow][currentCol]) { //this checks whether the bot's current position in the path is equal to a value "True" in the 'possibleLeakPositions' boolean array
                //if this condition is true, this means the bot has found the nearest cell that could possibly contain the leak.
                return currentCell; //return the currentCell coordiantes
            }

            //add each neighbor to the queue, marking them as visited by using the 'enqueueNeighborCell' method
            enqueueNeighborCell(botQueue, currentRow - 1, currentCol, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow + 1, currentCol, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow, currentCol - 1, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow, currentCol + 1, visited, possibleLeakPositions);
        }

        return null; //this will only return null if the BFS fails to find a single cell coordiante associated with a "True" value in our 'possibleLeakPositions' boolean array... in other words, if there is no possible leak present at all (just handles errors, this should never return)
    }

    private int[] BFSFalseCell(int row, int col, boolean[][] possibleLeakPositions) { //this method performs the exact same as 'BFSTrueCell' method, however it uses BFS path planning for the bot to travel from its current location to the nearest cell location that could not possibly contain the leak
        //a cell that could not possibly contain the leak is a cell coordinate in the 'possibleLeakPositions' boolean array that has a value of "False"
        Queue<int[]> botQueue = new LinkedList<>();
        boolean[][] visited = new boolean[rows][cols];
    
        botQueue.add(botPosition);
        visited[botPosition[0]][botPosition[1]] = true;
    
        while (!botQueue.isEmpty()) {
            int[] currentCell = botQueue.poll();
            int currentRow = currentCell[0];
            int currentCol = currentCell[1];
    
            if (!possibleLeakPositions[currentRow][currentCol]) { //this time, we check whether the bot's current position in the path is equal to a value of "False" in the 'possibleLeakPositions' boolean array
                return currentCell; 
            }
            
            enqueueNeighborCell(botQueue, currentRow - 1, currentCol, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow + 1, currentCol, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow, currentCol - 1, visited, possibleLeakPositions);
            enqueueNeighborCell(botQueue, currentRow, currentCol + 1, visited, possibleLeakPositions);
        }
    
        return null; //only returns if we never find a "False" cell in our 'possibleLeakPositions' boolean array, this should not happen (just for error handling)
    }

    private boolean isKPlusUnitsAway(boolean[][] possibleLeakPositions) { //this method will check whether the bot is positioned k+ units away from the nearest cell in 'possibleLeakPositions' with a value of "false"
        int[] nearestFalseCell = BFSFalseCell(botPosition[0], botPosition[1], possibleLeakPositions); //retrieve the coordinates of the nearest cell with "false" value from our bot's current position
    
        if (nearestFalseCell == null) { //just checks whether or not there are even any false cells, this condition shouldn't execute really... just error handling
            return true; //if condition passes, we can activate our bot's scanning since there are no false cells anywhere (false cells = cells that cannot possibly contain the leak)
        }
    
        double distToFalseCell = euclideanDistance(botPosition[0], botPosition[1], nearestFalseCell[0], nearestFalseCell[1]); //calculate and retrieve the distance in units to the closest false cell from the bot's current position
        return distToFalseCell >= k; //if the bot is k+ units away from the false cell, we can return true... return false otherwise
    }

    private int[] maxProbability() { //this method will traverse the leakProbabilities array and return the coordinate associated with the highest probability
        int[] maxProbabilityCoordinate = {0, 0}; //we will store the max prob coordinate and return this array
        double max = 0.0; //set our initial max equal to a probability of 0

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (leakProbabilities[i][j] > max) { //if the probability in coordinate (i,j) of 'leakProbabilities' is higher then max, we will set max to the value at that coordinate (this is continously done throughout the loop to achieve max probability)
                    max = leakProbabilities[i][j];
                    //retrieve and store coordiantes associated with the max probability value into our 'maxProbabilityCoordinate'
                    maxProbabilityCoordinate[0] = i; 
                    maxProbabilityCoordinate[1] = j;
                }
            }
        }

        return maxProbabilityCoordinate; //return this coordinate with the max probability value
    }

    private void enqueueNeighborCell(Queue<int[]> botQueue, int neighborRow, int neighborCol, boolean[][] visited, boolean[][] possibleLeakPositions) { //this method will add a neighbor coordinate to our 'botQueue' if it is not a wall (cell with a value of '1'), and is not already visited 
        if (inShip(neighborRow, neighborCol) && !visited[neighborRow][neighborCol] && ship[neighborRow][neighborCol] != 1) { //checks if the neighbor coordinate is within the ship bounds, is not already visited, and not a blocked/wall cell
            //if conditions pass, we can add that neighbor to our botQueue and set that coordinate as visited.
            botQueue.add(new int[]{neighborRow, neighborCol});
            visited[neighborRow][neighborCol] = true;
        }
    }
    
    private boolean scan(int row, int col) { //this method will perform the scanning of the bot, which will check each cell within the detection square of the (row,col) representing the bot's current position
        for (int i = row - k; i <= row + k; i++) {
            for (int j = col - k; j <= col + k; j++) {
                if (inShip(i, j) && ship[i][j] == 3) { //if the coordinate is within the ship and is equal to the leak value of '3', we can return true, meaning the bot has detected a leak in its vicinity
                    return true; 
                }
            }
        }
        return false; //if no leak has been detected in the vicinity, we can return false.
    }

    private void makeInference(boolean[][] possibleLeakPositions, boolean scanResult) { //this method will update and make new inferences about the possibleLeakPositions boolean array based on the boolean 'scanResult' which is the result of calling the scan() method
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                boolean cellsInSquare = withinDetectionSquare(i, j, botPosition[0], botPosition[1], k) && ship[i][j] != 1; //return true for 'cellsInSquare' if the current cell is part of the detection square and false if it is outside the detection square
                possibleLeakPositions[i][j] = scanResult ? cellsInSquare :  cellsInSquare; //updates the cells inside the detection square and the cells outside the detection square to either True (inside) and false(outside) or vice versa based on 
            }
        }
    }

    private boolean probabilitiyIncreaseCheck(double[][] updatedProbabilities) { //this method checks whether the calculated probability has increased when compared to the previous probabilities
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (updatedProbabilities[i][j] > leakProbabilities[i][j]) { //this if condition compares the passed in 'updatedProbabilities' with new probabilities to the original probability value in 'leakProbabilities'
                    return true; //returns true if the new probability value is > than the old probability value
                }
            }
        }
        return false; //returns false if otherwise
    }
    
    private double[][] calculateProbabilities(int row, int col, boolean[][] possibleLeakPositions) {//this method will update the probabilities as needed, taking in the original probabilities, all based on whether the cell is "true" or "false" (does or doesnt possibly contain probability)
        double[][] updatedProbabilities = new double[rows][cols];
        double totalProbabilities = 0.0;
        
        //iterate through each cell in the grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double distance = euclideanDistance(i, j, row, col); //calculate the euclidean distance between the current position (i,j) and the passed in position (row, col)
                double probability = Math.exp(-alpha * (distance - 1)); //calculates the probability value based on the given formula e^-a(dist - 1)
                
                //if the cell position possibly contains the leak (is set to "True") it will updates the probabilities by multiplying the existing probability in 'leakProbabilities[i][j]' by the newly calculated probability.
                //if the cell position does not possibly contain the leak (is set to "False") it will update the probabilities by multiplying the existing probability in 'leakProbabilities[i][j]' by the complement of the newly calculated probability
                updatedProbabilities[i][j] = possibleLeakPositions[i][j] ? leakProbabilities[i][j] * probability : leakProbabilities[i][j] * (1 - probability); 

                //store the total probability number so we can eventually use this to scale the new probabilities to a proportional value from 0 -> 1
                totalProbabilities += updatedProbabilities[i][j];
            }
        }
    
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                updatedProbabilities[i][j] /= totalProbabilities; //modify the updatedProbabilities by dividing each probability by the total probability so that each value is scaled from 0 -> 1
            }
        }
    
        return updatedProbabilities; //return the new updatedProbabilities double array
    }

    private void updateProbabilities(boolean scanResult) { //this method functions the exact same as the 'calculateProbabilities' method, however this method is designed to simply update the existing 'leakProbabilities' array in place and not return anything
        //takes in boolean 'scanResult' which represents whether the scan() method returned "True" or "False"
    
        double totalProbabilities = 0.0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double distance = euclideanDistance(i, j, botPosition[0], botPosition[1]);
                double probability = Math.exp(-alpha * (distance - 1));

                if (scanResult) {
                    leakProbabilities[i][j] *= probability;
                } else {
                    leakProbabilities[i][j] *= (1 - probability);
                }

                totalProbabilities += leakProbabilities[i][j];
            }
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                leakProbabilities[i][j] /= totalProbabilities;
            }
        }
    }

    private void updateProbabilitiesForTwoLeaks(boolean scanResult) { //this method also functions the exact same as 'calculateProbabilities' and 'updateProbabilities' however this method adds deals with two probabilities since we are dealing with two leaks
        double totalProbabilities = 0.0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double distanceToFirstLeak = euclideanDistance(i, j, botPosition[0], botPosition[1]);
                double probabilityFromFirstLeak = Math.exp(-alpha * (distanceToFirstLeak - 1));

                //now we retrieve the distance and probability value associated for a cells probability to contain the second leak or not
                double distanceToSecondLeak = euclideanDistance(i, j, secondLeakPosition[0], secondLeakPosition[1]);
                double probabilityFromSecondLeak = Math.exp(-alpha * (distanceToSecondLeak - 1));

                double totalProbability = probabilityFromFirstLeak + probabilityFromSecondLeak; //add the two probabilities together

                if (scanResult) {
                    leakProbabilities[i][j] *= probabilityFromFirstLeak / totalProbability;
                } else {
                    leakProbabilities[i][j] *= probabilityFromSecondLeak / totalProbability;
                }

                totalProbabilities += leakProbabilities[i][j];
            }
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                leakProbabilities[i][j] /= totalProbabilities;
            }
        }
    }

    public void senseBotOne() { //this method to perform the sensing simulation (including the bot's path/journey towards the leak)
        int iterations = 0;
    
        //start off by initializing the possible leak positions to be full of "True" values, this is because initially, the bot will assume every single cell could possibly contain the leak
        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
    
        while (iterations < maxIterations) { //this while loop (to prevent memory/heap overflows), will only run for a number of times less than maxIterations, a constant value defined in this class
            boolean scanResult = scan(botPosition[0], botPosition[1]);
            makeInference(possibleLeakPositions, scanResult); //call the 'makeInference' method in order to update the possibleLeakPositions boolean array, factoring in the detection square of the initial bot position 
            //the initial bot position is represented by 'botPosition[0]' and 'botPosition[1]'
            totalScans++; //increment the scans number to signify the bot has made a "scan"
    
            
            int[] nearestTrueCell = BFSTrueCell(botPosition[0], botPosition[1], possibleLeakPositions); //call our 'BFSTrueCell' method in order for our bot to use BFS to travel to the nearest "True" cell position in our 'possibleLeakPositions' 
            //nearestTrueCell now equals the coordinates of the nearest cell possibly containing the leak (value of "True")
            totalMoves++; //increment the number of moves now since the bot has made a moving action
    
            if (nearestTrueCell == null) { //this only executes if no cell has a value of "true", this is just for error handling since we know there is always a leak --> there is always a cell with "true"
                System.out.println("Error: No possible leak detected in the ship.");
                break; 
            }

            //set this new coordinate as our current bot position so now our bot can then make an inference using this current location 
            botPosition[0] = nearestTrueCell[0]; 
            botPosition[1] = nearestTrueCell[1];
    
            //check if the current bot position is equal to the leak position
            if (Arrays.equals(botPosition, leakPosition)) {
                System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by the bot. Success!"); //print location/success statement
                break; //we can exit out of the loop if this condition is true
            }
    
            iterations++;
        }
        //print out where the botOne plugged the leak
        System.out.println("BotOne has plugged the leak at position (" + botPosition[0] + ", " + botPosition[1] + ") in the ship ");
    }

    public void senseBotTwo() { //this method operates just like 'senseBotOne', the only difference being that now the bot can only call the 'makeInference' method (make a scan of the detection square) if the bot is k+ units away from the nearest cell with a "false" value
        int iterations = 0;
    
        //start off by initializing the possible leak positions to be full of "True" values, this is because initially, the bot will assume every single cell could possibly contain the leak
        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
    
        while (iterations < maxIterations) {
            // Check if the bot can activate the scan
            boolean canActivateScan = isKPlusUnitsAway(possibleLeakPositions); //call the 'isKPlusUnitsAway' method to check if the bot is k+ units away from the nearest false cell, set this result equal to 'canActivateScan'
    
            if (canActivateScan) { //if 'canActivateScan' returns true, this means the bot is k+ units away from the nearest "false" cell, and can now perform its scanning/inference making once again (similar to botOne process)

                //same exact process as code in 'senseBotOne'
                boolean scanResult = scan(botPosition[0], botPosition[1]);
                makeInference(possibleLeakPositions, scanResult);
                totalScans++;
    
            
                int[] nearestTrueCell = BFSTrueCell(botPosition[0], botPosition[1], possibleLeakPositions);
                totalMoves++;
    
                if (nearestTrueCell == null) {
                    System.out.println("Error: No possible leak detected in the ship.");
                    break;
                }
    
                botPosition[0] = nearestTrueCell[0];
                botPosition[1] = nearestTrueCell[1];
    
                if (Arrays.equals(botPosition, leakPosition)) {
                    System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot Two. Success!");
                    break;
                }
            } 
            iterations++;
        }
        System.out.println("BotTwo has plugged the leak at position (" + botPosition[0] + ", " + botPosition[1] + ") in the ship ");
    }

    public void senseBotThree() { //this method operates using probabilistic leak detectors, where botThree will repeatedly travel to the cell position with the highest probability of containing the leak
        int iterations = 0;
        while (iterations < maxIterations) {

            updateProbabilities(scan(botPosition[0], botPosition[1])); //update the individual probabilities of each cell coordinate containing the leak, passing in the result from our scan of the current bot position
            totalScans++; //increment the nunber of scans after probabilities are updated

            int[] nextMove = maxProbability(); //we will set our 'nextMove' equal to the cell coordinate returned by maxProbability, since we want our bot to travel to this coordiante with the highest probability over and over again

            //retrieve the row and col coordinates and set it equal to the current botPosition
            botPosition[0] = nextMove[0];
            botPosition[1] = nextMove[1];
            totalMoves++; //increment the number of moves after we moved to the cell with the highest proability

            // Check if the bot reaches the leak position
            if (Arrays.equals(botPosition, leakPosition)) { //check if the new bot position (that is in same cell with highest probability) is equal to the leak position... if so we completed our simulation
                System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot Three. Success!");
                break; //we can exit the loop if this condition is true
            }
            iterations++;
        }

        System.out.println("BotThree has plugged the leak at position (" + botPosition[0] + ", " + botPosition[1] + ") in the ship ");
    }

    public void senseBotFour() {//this bot works just like botThree, however the only tweak is that this bot will scan or check for a beep two times, and only if the probabiliy of the cell containing the leak increases in the second scan, will the 
                                //bot then move, otherwise the bot wiill stay in place. This bot also uses elements of botTwo, making sure the bot is k+ units away from the nearest "False" cell before scanning.
        int iterations = 0;
    
        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
    
        while (iterations < maxIterations) {
            //set 'canActivateScan' to "true" or "false" depending on if the bot is k+ units away from the nearest "false" cell
            boolean canActivateScan = isKPlusUnitsAway(possibleLeakPositions);
    
            if (canActivateScan) {
                //if we are k+ units away, our botFour can now scan, make the necessary inference, and update the scan counter
                boolean scanResult = scan(botPosition[0], botPosition[1]);
                makeInference(possibleLeakPositions, scanResult);
                totalScans++;

                if (iterations > 0) {
                    //retrieve a new set of updated probabilities using the 'calculateProbabilities' method
                    double[][] updatedProbabilities = calculateProbabilities(botPosition[0], botPosition[1], possibleLeakPositions);
    
                    //this condition will check if the updatedProbabilities array contains probabilities that are greater than the probabilities retrieved from the first scan
                    if (probabilitiyIncreaseCheck(updatedProbabilities)) {
                        //if this condition is true, we can now move the botFour. Increment the move counter, set our nextMove coordinates equal to our current botPosition coordinates
                        int[] nextMove = maxProbability();
                        botPosition[0] = nextMove[0];
                        botPosition[1] = nextMove[1];
                        totalMoves++;
    
                        // Check if the bot reaches the leak position
                        if (Arrays.equals(botPosition, leakPosition)) {
                            System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotFour. Success!.");
                            break; //we can exit the loop if this condition passes
                        }
                    } else {
                        //if the probability did not increase, we simply continue onwards, giving a print statement letting us know that the botFour did not make a move
                        System.out.println("BotFour stays in place...");
                        continue;
                    }
                }
            }
    
            iterations++;
        }

        System.out.println("Final BotFour position where it plugged leak: (" + botPosition[0] + ", " + botPosition[1] + ")");
    }

    public void senseBotFive() {//this method works just like BotOne, however now we are dealing with two leak positions
        int iterations = 0;

        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
        addSecondLeakPos(); //manually set a random initial position for our second leak in the generated ship (making sure no overlapping and that it is outside the bounds of the bot's initial detection square)

        while (iterations < maxIterations) {
            //retrieve the result of our bot's scans and make an inference based on that scan, update the scan counter
            boolean scanResult = scan(botPosition[0], botPosition[1]);
            makeInference(possibleLeakPositions, scanResult);
            totalScans++;

            //update our botPosition to nearest cell possibly containg the leak, and increment our moves 
            int[] nearestTrueCell = BFSTrueCell(botPosition[0], botPosition[1], possibleLeakPositions);
            totalMoves++;

            if (nearestTrueCell == null) { //error handling
                System.out.println("Error: No possible leak detected in the ship.");
                break; 
            }

            botPosition[0] = nearestTrueCell[0];
            botPosition[1] = nearestTrueCell[1];

            if (Arrays.equals(botPosition, leakPosition)) {
                System.out.println("First leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotFive.");
                possibleLeakPositions[leakPosition[0]][leakPosition[1]] = false; //setting this position equal to "false" essentially removes and plugs the first leak from the ship
            }

            if (Arrays.equals(botPosition, secondLeakPosition)) {
                System.out.println("Second leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotFive. Success!");
                break; //once the second leak is found, we can now exit the loop
            }

            iterations++;
        }
        //print the locations of both leaks (where the botFive plugged both)
        System.out.println("Final BotFive position where it plugged Leak #1: (" + botPosition[0] + ", " + botPosition[1] + ")");
        System.out.println("Final BotFive position where it plugged Leak #2: (" + secondLeakPosition[0] + ", " + secondLeakPosition[1] + ")");
    }

    public void senseBotSix() { //this method for botSix's simulation will work just like BotTwo, except it is able to move to the leak in a more efficient manner. It does so more efficiently by making sure its detection squares yeild more "true" cell values
        int iterations = 0;
    
        //initialize possibleLeakPositions outside the loop
        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
        addSecondLeakPos(); //set the position for the second leak
    
        while (iterations < maxIterations) {
            //check if the bot can activate a scan
            boolean canActivateScan = isKPlusUnitsAway(possibleLeakPositions);
    
            if (canActivateScan) {
                //scan, make inference based on scan, and update number of scans
                boolean scanResult = scan(botPosition[0], botPosition[1]);
                makeInference(possibleLeakPositions, scanResult);
                totalScans++;
    
                //find and set 'nearestTrueCell' to the nearest cell with a value "true" using BFS
                int[] nearestTrueCell = BFSTrueCell(botPosition[0], botPosition[1], possibleLeakPositions);
                totalMoves++;
    
                if (nearestTrueCell == null) {//error handling
                    System.out.println("Error: No possible leak detected in the ship.");
                    break; 
                }
    
                botPosition[0] = nearestTrueCell[0];
                botPosition[1] = nearestTrueCell[1];
    
                //check if the bot reaches the first leak position
                if (Arrays.equals(botPosition, leakPosition)) {
                    System.out.println("First leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot Six.");
                    possibleLeakPositions[leakPosition[0]][leakPosition[1]] = false;
                }
    
                // Check if the bot reaches the second leak position
                if (Arrays.equals(botPosition, secondLeakPosition)) {
                    System.out.println("Second leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot Six.");
                    // Remove the second leak
                    possibleLeakPositions[secondLeakPosition[0]][secondLeakPosition[1]] = false;
                }
            } 
            iterations++;
        }
        System.out.println("Final BotSix position where it plugged Leak #1: (" + botPosition[0] + ", " + botPosition[1] + ")");
        System.out.println("Final BotSix position where it plugged Leak #2: (" + secondLeakPosition[0] + ", " + secondLeakPosition[1] + ")");
    }

    public void senseBotSeven() { //this method for botSeven's simulation works just like BotThree (using probabalistic leak detectors) however this time there are two leaks for it to deal with
        int iterations = 0;

        boolean[][] possibleLeakPositions = initializePossibleLeakPositions();
        addSecondLeakPos(); //manually add our second leak position

        while (iterations < maxIterations) {
            //scan the detection square of the current position, increment our scan counter, update the probabilities based on the scan result
            boolean scanResult = scan(botPosition[0], botPosition[1]);
            updateProbabilities(scanResult);
            totalScans++;

            //update our botPosition to be equal to the position of 'nearestTrueCell' (which uses BFS to find the necessary cell coordinate)
            int[] nearestTrueCell = BFSTrueCell(botPosition[0], botPosition[1], possibleLeakPositions);
            totalMoves++;

            if (nearestTrueCell == null) { //error handling
                System.out.println("Error: No possible leak detected in the ship.");
                break;
            }
            
            //set new bot positions 
            botPosition[0] = nearestTrueCell[0];
            botPosition[1] = nearestTrueCell[1];

            if (Arrays.equals(botPosition, leakPosition)) {
                System.out.println("First leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotSeven.");
                //set this cell coordinate to "false", essentially removing/plugging the leak
                possibleLeakPositions[leakPosition[0]][leakPosition[1]] = false;
            }

            //check if the bot has reached the second leak position
            if (Arrays.equals(botPosition, secondLeakPosition)) {
                System.out.println("Second leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotSeven. Success!");
                break; //exit the loop once the second leak is found
            }

            iterations++;
        }
 
        System.out.println("Final BotSeven position where it plugged Leak #1: (" + botPosition[0] + ", " + botPosition[1] + ")");
        System.out.println("Final BotSeven position where it plugged Leak #2: (" + secondLeakPosition[0] + ", " + secondLeakPosition[1] + ")");
    }

    public void senseBotEight() {//this method for botEight's simulation works just like BotThree, however now the probability updates are corrected to account for the fact there are two leaks
        int iterations = 0;

        //same process pretty much as botThree...
    
        while (iterations < maxIterations) {
            
            //make sure to update the probabilities to account for BOTH leaks, as done by the 'updateProbabilitiesForTwoLeaks' method
            updateProbabilitiesForTwoLeaks(scan(botPosition[0], botPosition[1]));
            totalScans++;
    
    
            int[] nextMove = maxProbability();
            botPosition[0] = nextMove[0];
            botPosition[1] = nextMove[1];
            totalMoves++;
    
            if (Arrays.equals(botPosition, leakPosition)) {
                System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot 8. Exiting simulation.");
                break; 
            }

            if (Arrays.equals(botPosition, secondLeakPosition)) {
                System.out.println("Second leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by Bot Seven. Exiting simulation.");
                break;
            }
    
            iterations++;
        }
    
        System.out.println("Final BotEight position where it plugged Leak #1: (" + botPosition[0] + ", " + botPosition[1] + ")");
        System.out.println("Final BotEight position where it plugged Leak #2: (" + secondLeakPosition[0] + ", " + secondLeakPosition[1] + ")");
    }

    public void senseBotNine() { //this method for botNine makes sure to use the updateProbabilitiesForTwoLeaks method twice, ensure that the probability of a leak existing in a cell's position is consistent enough for the bot to then move
        int iterations = 0;
    
        while (iterations < maxIterations) {
    
            updateProbabilitiesForTwoLeaks(scan(botPosition[0], botPosition[1]));
    
            int[] nextMove = maxProbability();
            botPosition[0] = nextMove[0];
            botPosition[1] = nextMove[1];
            totalMoves++;
    
            if (Arrays.equals(botPosition, leakPosition)) {
                System.out.println("Leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotNine. Success!");
                break;
            }
    
            updateProbabilitiesForTwoLeaks((scan(botPosition[0], botPosition[1])));
            totalScans++;
    
            if (Arrays.equals(botPosition, secondLeakPosition)) {
                System.out.println("Second leak found at position: (" + botPosition[0] + ", " + botPosition[1] + ") and has been plugged by BotNine. Success!");
                break;
            }
    
            iterations++;
        }
        
        System.out.println("Final BotNine position where it plugged Leak #1: (" + botPosition[0] + ", " + botPosition[1] + ")");
        System.out.println("Final BotNine position where it plugged Leak #2: (" + secondLeakPosition[0] + ", " + secondLeakPosition[1] + ")");
    }

    public static void main(String[] args) {
    
        //create a BotOne -> botNine 'Bots' object using a ship of size 50x50 generated from the ShipGenerator class, with a passed in k value to represent the size of our detection squares used in the simulation
        //in this case, k is set to equal 3, but any number can be used such that the resulting detection square is not the same size of the ship itself

        Bots botOne = new Bots(new ShipGenerator(50, 50, 3), 3);
        botOne.senseBotOne(); //call the 'senseBotOne' method to run simulation
        botOne.displayTotalActions();//call the 'displayTotalActions' to retrieve the number of actions this bot took

        /*** Same process to run the other bots (two through nine) and retrieve their number of actions used as well ***/

        // Bots botTwo = new Bots(new ShipGenerator(50, 50, 3), 3);
        // botTwo.senseBotTwo(); 
        // botTwo.displayTotalActions();

        // Bots botThree = new Bots(new ShipGenerator(50, 50, 3), 3, 0.2); // Example alpha value: 0.1
        // botThree.senseBotThree();
        // botThree.displayTotalActions();

        // Bots botFour = new Bots(new ShipGenerator(50, 50, 3), 3, 0.2);
        // botFour.senseBotFour();
        // botFour.displayTotalActions();

        // Bots botFive = new Bots(new ShipGenerator(50, 50, 3), 3);
        // botFive.senseBotFive();
        // botFive.displayTotalActions();

        // Bots botSix = new Bots(new ShipGenerator(50, 50, 3), 3);
        // botSix.senseBotSix();
        // botSix.displayTotalActions();

        // Bots botSeven = new Bots(new ShipGenerator(50, 50, 3), 3, 0.2);
        // botSeven.senseBotSeven();
        // botSeven.displayTotalActions();

        // Bots botEight = new Bots(new ShipGenerator(50, 50, 3), 3, 0.2);
        // botEight.senseBotEight();
        // botEight.displayTotalActions();

        // Bots botNine = new Bots(new ShipGenerator(50, 50, 3), 3, 0.2);
        // botNine.senseBotNine();
        // botNine.displayTotalActions();

    }
}